{"version":3,"file":"index.mjs","sources":["../node_modules/debug/src/index.js","../node_modules/readable-stream/readable.js","../lib/validate.js","../lib/destroy.js","../lib/_transform.js","../lib/main.js","../lib/object_mode.js","../lib/factory.js","../lib/ctor.js","../lib/index.js"],"sourcesContent":["/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","var Stream = require('stream');\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream;\n  exports = module.exports = Stream.Readable;\n  exports.Readable = Stream.Readable;\n  exports.Writable = Stream.Writable;\n  exports.Duplex = Stream.Duplex;\n  exports.Transform = Stream.Transform;\n  exports.PassThrough = Stream.PassThrough;\n  exports.Stream = Stream;\n} else {\n  exports = module.exports = require('./lib/_stream_readable.js');\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = require('./lib/_stream_writable.js');\n  exports.Duplex = require('./lib/_stream_duplex.js');\n  exports.Transform = require('./lib/_stream_transform.js');\n  exports.PassThrough = require('./lib/_stream_passthrough.js');\n}\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isObject = require( '@stdlib/assert-is-plain-object' );\nvar hasOwnProp = require( '@stdlib/assert-has-own-property' );\nvar isFunction = require( '@stdlib/assert-is-function' );\nvar isBoolean = require( '@stdlib/assert-is-boolean' ).isPrimitive;\nvar isNonNegative = require( '@stdlib/assert-is-nonnegative-number' ).isPrimitive;\nvar isString = require( '@stdlib/assert-is-string' ).isPrimitive;\nvar format = require( '@stdlib/string-format' );\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Options} options - function options\n* @param {Function} [options.transform] - callback to invoke upon receiving a new chunk\n* @param {Function} [options.flush] - callback to invoke after receiving all chunks and prior to the stream closing\n* @param {boolean} [options.objectMode] - specifies whether a stream should operate in object mode\n* @param {(string|null)} [options.encoding] - specifies how `Buffer` objects should be decoded to `strings`\n* @param {NonNegativeNumber} [options.highWaterMark] - specifies the `Buffer` level for when `write()` starts returning `false`\n* @param {boolean} [options.allowHalfOpen] - specifies whether the stream should remain open even if one side ends\n* @param {boolean} [options.decodeStrings] - specifies whether to decode `strings` into `Buffer` objects when writing\n* @returns {(Error|null)} null or an error object\n*/\nfunction validate( opts, options ) {\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );\n\t}\n\tif ( hasOwnProp( options, 'transform' ) ) {\n\t\topts.transform = options.transform;\n\t\tif ( !isFunction( opts.transform ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a function. Option: `%s`.', 'transform', opts.transform ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'flush' ) ) {\n\t\topts.flush = options.flush;\n\t\tif ( !isFunction( opts.flush ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a function. Option: `%s`.', 'flush', opts.flush ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'objectMode' ) ) {\n\t\topts.objectMode = options.objectMode;\n\t\tif ( !isBoolean( opts.objectMode ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a boolean. Option: `%s`.', 'objectMode', opts.objectMode ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'encoding' ) ) {\n\t\topts.encoding = options.encoding;\n\t\tif ( !isString( opts.encoding ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a string. Option: `%s`.', 'encoding', opts.encoding ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'allowHalfOpen' ) ) {\n\t\topts.allowHalfOpen = options.allowHalfOpen;\n\t\tif ( !isBoolean( opts.allowHalfOpen ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a boolean. Option: `%s`.', 'allowHalfOpen', opts.allowHalfOpen ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'highWaterMark' ) ) {\n\t\topts.highWaterMark = options.highWaterMark;\n\t\tif ( !isNonNegative( opts.highWaterMark ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a nonnegative number. Option: `%s`.', 'highWaterMark', opts.highWaterMark ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'decodeStrings' ) ) {\n\t\topts.decodeStrings = options.decodeStrings;\n\t\tif ( !isBoolean( opts.decodeStrings ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a boolean. Option: `%s`.', 'decodeStrings', opts.decodeStrings ) );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nmodule.exports = validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nvar nextTick = require( '@stdlib/utils-next-tick' );\n\n\n// VARIABLES //\n\nvar debug = logger( 'transform-stream:destroy' );\n\n\n// MAIN //\n\n/**\n* Gracefully destroys a stream, providing backward compatibility.\n*\n* @private\n* @param {Object} [error] - optional error message\n* @returns {Stream} stream instance\n*/\nfunction destroy( error ) {\n\t/* eslint-disable no-invalid-this */\n\tvar self;\n\tif ( this._destroyed ) {\n\t\tdebug( 'Attempted to destroy an already destroyed stream.' );\n\t\treturn this;\n\t}\n\tself = this;\n\tthis._destroyed = true;\n\n\tnextTick( close );\n\n\treturn this;\n\n\t/**\n\t* Closes a stream.\n\t*\n\t* @private\n\t*/\n\tfunction close() {\n\t\tif ( error ) {\n\t\t\tdebug( 'Stream was destroyed due to an error. Error: %s.', JSON.stringify( error ) );\n\t\t\tself.emit( 'error', error );\n\t\t}\n\t\tdebug( 'Closing the stream...' );\n\t\tself.emit( 'close' );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = destroy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\n\n\n// VARIABLES //\n\nvar debug = logger( 'transform-stream:transform' );\n\n\n// MAIN //\n\n/**\n* Implements the `_transform` method as a pass through.\n*\n* @private\n* @param {(Uint8Array|Buffer|string)} chunk - streamed chunk\n* @param {string} encoding - Buffer encoding\n* @param {Callback} clbk - callback to invoke after transforming the streamed chunk\n*/\nfunction transform( chunk, encoding, clbk ) {\n\tdebug( 'Received a new chunk. Chunk: %s. Encoding: %s.', chunk.toString(), encoding );\n\tclbk( null, chunk );\n}\n\n\n// EXPORTS //\n\nmodule.exports = transform;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nvar Transform = require( 'readable-stream' ).Transform;\nvar inherit = require( '@stdlib/utils-inherit' );\nvar copy = require( '@stdlib/utils-copy' );\nvar DEFAULTS = require( './defaults.json' );\nvar validate = require( './validate.js' );\nvar destroy = require( './destroy.js' );\nvar _transform = require( './_transform.js' ); // eslint-disable-line no-underscore-dangle\n\n\n// VARIABLES //\n\nvar debug = logger( 'transform-stream:main' );\n\n\n// MAIN //\n\n/**\n* Transform stream constructor.\n*\n* @constructor\n* @param {Options} [options] - stream options\n* @param {Function} [options.transform] - callback to invoke upon receiving a new chunk\n* @param {Function} [options.flush] - callback to invoke after receiving all chunks and prior to the stream closing\n* @param {boolean} [options.objectMode=false] - specifies whether stream should operate in object mode\n* @param {(string|null)} [options.encoding=null] - specifies how `Buffer` objects should be decoded to `strings`\n* @param {NonNegativeNumber} [options.highWaterMark] - specifies the `Buffer` level for when `write()` starts returning `false`\n* @param {boolean} [options.allowHalfOpen=false] - specifies whether the stream should remain open even if one side ends\n* @param {boolean} [options.decodeStrings=true] - specifies whether to decode `strings` into `Buffer` objects when writing\n* @throws {TypeError} must provide valid options\n* @returns {TransformStream} transform stream\n*\n* @example\n* var stdout = require( '@stdlib/streams-node-stdout' );\n*\n* function transform( chunk, enc, clbk ) {\n*     clbk( null, chunk.toString()+'\\n' );\n* }\n*\n* var opts = {\n*     'transform': transform\n* };\n* var stream = new TransformStream( opts );\n*\n* stream.pipe( stdout );\n*\n* stream.write( '1' );\n* stream.write( '2' );\n* stream.write( '3' );\n*\n* stream.end();\n*\n* // prints: '1\\n2\\n3\\n'\n*/\nfunction TransformStream( options ) {\n\tvar opts;\n\tvar err;\n\tif ( !( this instanceof TransformStream ) ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn new TransformStream( options );\n\t\t}\n\t\treturn new TransformStream();\n\t}\n\topts = copy( DEFAULTS );\n\tif ( arguments.length ) {\n\t\terr = validate( opts, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\tdebug( 'Creating a transform stream configured with the following options: %s.', JSON.stringify( opts ) );\n\tTransform.call( this, opts );\n\tthis._destroyed = false;\n\tif ( opts.transform ) {\n\t\tthis._transform = opts.transform;\n\t} else {\n\t\tthis._transform = _transform;\n\t}\n\tif ( opts.flush ) {\n\t\tthis._flush = opts.flush;\n\t}\n\treturn this;\n}\n\n/*\n* Inherit from the `Transform` prototype.\n*/\ninherit( TransformStream, Transform );\n\n/**\n* Gracefully destroys a stream, providing backward compatibility.\n*\n* @name destroy\n* @memberof TransformStream.prototype\n* @type {Function}\n* @param {Object} [error] - optional error message\n* @returns {TransformStream} stream instance\n*/\nTransformStream.prototype.destroy = destroy;\n\n\n// EXPORTS //\n\nmodule.exports = TransformStream;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isObject = require( '@stdlib/assert-is-plain-object' );\nvar format = require( '@stdlib/string-format' );\nvar copy = require( '@stdlib/utils-copy' );\nvar Stream = require( './main.js' );\n\n\n// MAIN //\n\n/**\n* Returns a transform stream with `objectMode` set to `true`.\n*\n* @param {Options} [options] - stream options\n* @param {Function} [options.transform] - callback to invoke upon receiving a new chunk\n* @param {Function} [options.flush] - callback to invoke after receiving all chunks and prior to the stream closing\n* @param {(string|null)} [options.encoding=null] - specifies how `Buffer` objects should be decoded to `strings`\n* @param {NonNegativeNumber} [options.highWaterMark] - specifies the `Buffer` level for when `write()` starts returning `false`\n* @param {boolean} [options.allowHalfOpen=false] - specifies whether the stream should remain open even if one side ends\n* @param {boolean} [options.decodeStrings=true] - specifies whether to decode `strings` into `Buffer` objects when writing\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {TransformStream} transform stream\n*\n* @example\n* var stdout = require( '@stdlib/streams-node-stdout' );\n*\n* function stringify( chunk, enc, clbk ) {\n*     clbk( null, JSON.stringify( chunk ) );\n* }\n*\n* function newline( chunk, enc, clbk ) {\n*     clbk( null, chunk+'\\n' );\n* }\n*\n* var s1 = objectMode({\n*     'transform': stringify\n* });\n*\n* var s2 = objectMode({\n*     'transform': newline\n* });\n*\n* s1.pipe( s2 ).pipe( stdout );\n*\n* s1.write( {'value': 'a'} );\n* s1.write( {'value': 'b'} );\n* s1.write( {'value': 'c'} );\n*\n* s1.end();\n*\n* // prints: '{\"value\":\"a\"}\\n{\"value\":\"b\"}\\n{\"value\":\"c\"}\\n'\n*/\nfunction objectMode( options ) {\n\tvar opts;\n\tif ( arguments.length ) {\n\t\tif ( !isObject( options ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );\n\t\t}\n\t\topts = copy( options );\n\t} else {\n\t\topts = {};\n\t}\n\topts.objectMode = true;\n\treturn new Stream( opts );\n}\n\n\n// EXPORTS //\n\nmodule.exports = objectMode;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isObject = require( '@stdlib/assert-is-plain-object' );\nvar format = require( '@stdlib/string-format' );\nvar copy = require( '@stdlib/utils-copy' );\nvar Stream = require( './main.js' );\n\n\n// MAIN //\n\n/**\n* Creates a reusable transform stream factory.\n*\n* @param {Options} [options] - stream options\n* @param {boolean} [options.objectMode=false] - specifies whether a stream should operate in object mode\n* @param {(string|null)} [options.encoding=null] - specifies how `Buffer` objects should be decoded to `strings`\n* @param {NonNegativeNumber} [options.highWaterMark] - specifies the `Buffer` level for when `write()` starts returning `false`\n* @param {boolean} [options.allowHalfOpen=false] - specifies whether the stream should remain open even if one side ends\n* @param {boolean} [options.decodeStrings=true] - specifies whether to decode `strings` into `Buffer` objects when writing\n* @throws {TypeError} options argument must be an object\n* @returns {Function} transform stream factory\n*\n* @example\n* function transform( chunk, enc, clbk ) {\n*     clbk( null, chunk.toString()+'\\n' );\n* }\n*\n* var opts = {\n*     'objectMode': true,\n*     'encoding': 'utf8',\n*     'highWaterMark': 64,\n*     'decodeStrings': false\n* };\n*\n* var factory = streamFactory( opts );\n*\n* // Create 10 identically configured streams...\n* var streams = [];\n* var i;\n* for ( i = 0; i < 10; i++ ) {\n*     streams.push( factory( transform ) );\n* }\n*/\nfunction streamFactory( options ) {\n\tvar opts;\n\tif ( arguments.length ) {\n\t\tif ( !isObject( options ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );\n\t\t}\n\t\topts = copy( options );\n\t} else {\n\t\topts = {};\n\t}\n\treturn createStream;\n\n\t/**\n\t* Creates a transform stream.\n\t*\n\t* @private\n\t* @param {Function} transform - callback to invoke upon receiving a new chunk\n\t* @param {Function} [flush] - callback to invoke after receiving all chunks and prior to the stream closing\n\t* @throws {TypeError} must provide valid options\n\t* @throws {TypeError} transform callback must be a function\n\t* @throws {TypeError} flush callback must be a function\n\t* @returns {TransformStream} transform stream\n\t*/\n\tfunction createStream( transform, flush ) {\n\t\topts.transform = transform;\n\t\tif ( arguments.length > 1 ) {\n\t\t\topts.flush = flush;\n\t\t} else {\n\t\t\tdelete opts.flush; // clear any previous `flush`\n\t\t}\n\t\treturn new Stream( opts );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = streamFactory;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nvar Transform = require( 'readable-stream' ).Transform;\nvar inherit = require( '@stdlib/utils-inherit' );\nvar copy = require( '@stdlib/utils-copy' );\nvar DEFAULTS = require( './defaults.json' );\nvar validate = require( './validate.js' );\nvar destroy = require( './destroy.js' );\nvar _transform = require( './_transform.js' ); // eslint-disable-line no-underscore-dangle\n\n\n// VARIABLES //\n\nvar debug = logger( 'transform-stream:ctor' );\n\n\n// MAIN //\n\n/**\n* Transform stream constructor factory.\n*\n* @param {Options} [options] - stream options\n* @param {Function} [options.transform] - callback to invoke upon receiving a new chunk\n* @param {Function} [options.flush] - callback to invoke after receiving all chunks and prior to the stream closing\n* @param {boolean} [options.objectMode=false] - specifies whether a stream should operate in object mode\n* @param {(string|null)} [options.encoding=null] - specifies how `Buffer` objects should be decoded to `strings`\n* @param {NonNegativeNumber} [options.highWaterMark] - specifies the `Buffer` level for when `write()` starts returning `false`\n* @param {boolean} [options.allowHalfOpen=false] - specifies whether the stream should remain open even if one side ends\n* @param {boolean} [options.decodeStrings=true] - specifies whether to decode `strings` into `Buffer` objects when writing\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {Function} Transform stream constructor\n*\n* @example\n* var stdout = require( '@stdlib/streams-node-stdout' );\n*\n* function transform( chunk, enc, clbk ) {\n*     clbk( null, chunk.toString()+'\\n' );\n* }\n*\n* var opts = {\n*     'transform': transform\n* };\n*\n* var TransformStream = ctor( opts );\n*\n* var stream = new TransformStream();\n*\n* stream.pipe( stdout );\n*\n* stream.write( '1' );\n* stream.write( '2' );\n* stream.write( '3' );\n*\n* stream.end();\n*\n* // prints: '1\\n2\\n3\\n'\n*/\nfunction ctor( options ) {\n\tvar transform;\n\tvar copts;\n\tvar err;\n\n\tcopts = copy( DEFAULTS );\n\tif ( arguments.length ) {\n\t\terr = validate( copts, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\tif ( copts.transform ) {\n\t\ttransform = copts.transform;\n\t} else {\n\t\ttransform = _transform;\n\t}\n\t/**\n\t* Transform stream constructor.\n\t*\n\t* @private\n\t* @constructor\n\t* @param {Options} [options] - stream options\n\t* @param {boolean} [options.objectMode=false] - specifies whether a stream should operate in object mode\n\t* @param {(string|null)} [options.encoding=null] - specifies how `Buffer` objects should be decoded to `strings`\n\t* @param {NonNegativeNumber} [options.highWaterMark] - specifies the `Buffer` level for when `write()` starts returning `false`\n\t* @param {boolean} [options.allowHalfOpen=false] - specifies whether the stream should remain open even if one side ends\n\t* @param {boolean} [options.decodeStrings=true] - specifies whether to decode `strings` into `Buffer` objects when writing\n\t* @throws {TypeError} options argument must be an object\n\t* @throws {TypeError} must provide valid options\n\t* @returns {TransformStream} transform stream\n\t*\n\t* @example\n\t* var stdout = require( '@stdlib/streams-node-stdout' );\n\t*\n\t* var stream = new TransformStream();\n\t*\n\t* stream.pipe( stdout );\n\t*\n\t* stream.write( '1' );\n\t* stream.write( '2' );\n\t* stream.write( '3' );\n\t*\n\t* stream.end();\n\t*\n\t* // prints: '1\\n2\\n3\\n'\n\t*/\n\tfunction TransformStream( options ) {\n\t\tvar opts;\n\t\tvar err;\n\t\tif ( !( this instanceof TransformStream ) ) {\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn new TransformStream( options );\n\t\t\t}\n\t\t\treturn new TransformStream();\n\t\t}\n\t\topts = copy( copts );\n\t\tif ( arguments.length ) {\n\t\t\terr = validate( opts, options );\n\t\t\tif ( err ) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t\tdebug( 'Creating a transform stream configured with the following options: %s.', JSON.stringify( opts ) );\n\t\tTransform.call( this, opts );\n\t\tthis._destroyed = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t* Inherit from the `Transform` prototype.\n\t*/\n\tinherit( TransformStream, Transform );\n\n\t/**\n\t* Implements the `_transform` method.\n\t*\n\t* @private\n\t* @name _transform\n\t* @memberof TransformStream.prototype\n\t* @type {Function}\n\t* @param {(Buffer|string)} chunk - streamed chunk\n\t* @param {string} encoding - Buffer encoding\n\t* @param {Callback} clbk - callback to invoke after transforming the streamed chunk\n\t*/\n\tTransformStream.prototype._transform = transform; // eslint-disable-line no-underscore-dangle\n\n\tif ( copts.flush ) {\n\t\t/**\n\t\t* Implements the `_flush` method.\n\t\t*\n\t\t* @private\n\t\t* @name _flush\n\t\t* @memberof TransformStream.prototype\n\t\t* @type {Function}\n\t\t* @param {Callback} callback to invoke after performing flush tasks\n\t\t*/\n\t\tTransformStream.prototype._flush = copts.flush; // eslint-disable-line no-underscore-dangle\n\t}\n\n\t/**\n\t* Gracefully destroys a stream, providing backward compatibility.\n\t*\n\t* @private\n\t* @name destroy\n\t* @memberof TransformStream.prototype\n\t* @type {Function}\n\t* @param {Object} [error] - optional error message\n\t* @returns {TransformStream} stream instance\n\t*/\n\tTransformStream.prototype.destroy = destroy;\n\n\treturn TransformStream;\n}\n\n\n// EXPORTS //\n\nmodule.exports = ctor;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Transform stream.\n*\n* @module @stdlib/streams-node-transform\n*\n* @example\n* var stdout = require( '@stdlib/streams-node-stdout' );\n* var transformStream = require( '@stdlib/streams-node-transform' );\n*\n* function transform( chunk, enc, clbk ) {\n*     clbk( null, chunk.toString()+'\\n' );\n* }\n*\n* var opts = {\n*     'transform': transform\n* };\n* var stream = transformStream( opts );\n*\n* stream.pipe( stdout );\n*\n* stream.write( '1' );\n* stream.write( '2' );\n* stream.write( '3' );\n*\n* stream.end();\n* // => '1\\n2\\n3\\n'\n*\n*\n* @example\n* var transformStream = require( '@stdlib/streams-node-transform' );\n*\n* function transform( chunk, enc, clbk ) {\n*     clbk( null, chunk.toString()+'\\n' );\n* }\n*\n* var opts = {\n*     'objectMode': true,\n*     'encoding': 'utf8',\n*     'highWaterMark': 64,\n*     'decodeStrings': false\n* };\n*\n* var factory = transformStream.factory( opts );\n*\n* // Create 10 identically configured streams...\n* var streams = [];\n* var i;\n* for ( i = 0; i < 10; i++ ) {\n*     streams.push( factory( transform ) );\n* }\n*\n*\n* @example\n* var stdout = require( '@stdlib/streams-node-stdout' );\n* var transformStream = require( '@stdlib/streams-node-transform' );\n*\n* function stringify( chunk, enc, clbk ) {\n*     clbk( null, JSON.stringify( chunk ) );\n* }\n*\n* function newline( chunk, enc, clbk ) {\n*     clbk( null, chunk+'\\n' );\n* }\n*\n* var s1 = transformStream.objectMode({\n*     'transform': stringify\n* });\n*\n* var s2 = transformStream.objectMode({\n*     'transform': newline\n* });\n*\n* s1.pipe( s2 ).pipe( stdout );\n*\n* s1.write( {'value': 'a'} );\n* s1.write( {'value': 'b'} );\n* s1.write( {'value': 'c'} );\n*\n* s1.end();\n* // => '{\"value\":\"a\"}\\n{\"value\":\"b\"}\\n{\"value\":\"c\"}\\n'\n*\n*\n* @example\n* var stdout = require( '@stdlib/streams-node-stdout' );\n* var transformStream = require( '@stdlib/streams-node-transform' );\n*\n* function transform( chunk, enc, clbk ) {\n*     clbk( null, chunk.toString()+'\\n' );\n* }\n*\n* var opts = {\n*     'transform': transform\n* };\n*\n* var Stream = transformStream.ctor( opts );\n*\n* var stream = new Stream();\n*\n* stream.pipe( stdout );\n*\n* stream.write( '1' );\n* stream.write( '2' );\n* stream.write( '3' );\n*\n* stream.end();\n* // => '1\\n2\\n3\\n'\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar transform = require( './main.js' );\nvar objectMode = require( './object_mode.js' );\nvar factory = require( './factory.js' );\nvar ctor = require( './ctor.js' );\n\n\n// MAIN //\n\nsetReadOnly( transform, 'objectMode', objectMode );\nsetReadOnly( transform, 'factory', factory );\nsetReadOnly( transform, 'ctor', ctor );\n\n\n// EXPORTS //\n\nmodule.exports = transform;\n"],"names":["module","exports","process","type","require","Stream","env","READABLE_STREAM","Readable","Writable","Duplex","Transform","PassThrough","isObject","require$$0","hasOwnProp","require$$1","isFunction","require$$2","isBoolean","require$$3","isPrimitive","isNonNegative","require$$4","isString","require$$5","format","require$$6","validate_1","opts","options","transform","TypeError","flush","objectMode","encoding","allowHalfOpen","highWaterMark","decodeStrings","nextTick","debug","destroy_1","error","self","this","_destroyed","JSON","stringify","emit","_transform","chunk","clbk","toString","logger","inherit","copy","DEFAULTS","validate","destroy","require$$7","TransformStream","err","arguments","length","call","_flush","prototype","main","object_mode","factory","createStream","ctor_1","copts","setReadOnly","ctor","lib"],"mappings":";;2oGAMEA,OAAOC,aADc,IAAZC,GAA4C,aAAjBA,EAAQC,KAC3BC,QAAQ,gBAERA,QAAQ,sDCRvBC,EAASD,QAAQ,UACe,YAAhCF,EAAQI,IAAIC,iBAAiCF,GAC/CL,OAAOC,QAAUI,EACjBJ,QAAUD,OAAOC,QAAUI,EAAOG,SAClCP,QAAQO,SAAWH,EAAOG,SAC1BP,QAAQQ,SAAWJ,EAAOI,SAC1BR,QAAQS,OAASL,EAAOK,OACxBT,QAAQU,UAAYN,EAAOM,UAC3BV,QAAQW,YAAcP,EAAOO,YAC7BX,QAAQI,OAASA,IAEjBJ,QAAUD,OAAOC,QAAUG,QAAQ,6BACnCH,QAAQI,OAASA,GAAUJ,QAC3BA,QAAQO,SAAWP,QACnBA,QAAQQ,SAAWL,QAAQ,6BAC3BH,QAAQS,OAASN,QAAQ,2BACzBH,QAAQU,UAAYP,QAAQ,8BAC5BH,QAAQW,YAAcR,QAAQ,4ICK5BS,EAAWC,EACXC,EAAaC,EACbC,EAAaC,EACbC,EAAYC,EAAuCC,YACnDC,EAAgBC,EAAkDF,YAClEG,EAAWC,EAAsCJ,YACjDK,EAASC,EAwEb,IAAAC,EApDA,SAAmBC,EAAMC,GACxB,OAAMjB,EAAUiB,GAGXf,EAAYe,EAAS,eACzBD,EAAKE,UAAYD,EAAQC,WACnBd,EAAYY,EAAKE,YACf,IAAIC,UAAWN,EAAQ,gEAAiE,YAAaG,EAAKE,YAG9GhB,EAAYe,EAAS,WACzBD,EAAKI,MAAQH,EAAQG,OACfhB,EAAYY,EAAKI,QACf,IAAID,UAAWN,EAAQ,gEAAiE,QAASG,EAAKI,QAG1GlB,EAAYe,EAAS,gBACzBD,EAAKK,WAAaJ,EAAQI,YACpBf,EAAWU,EAAKK,aACd,IAAIF,UAAWN,EAAQ,+DAAgE,aAAcG,EAAKK,aAG9GnB,EAAYe,EAAS,cACzBD,EAAKM,SAAWL,EAAQK,UAClBX,EAAUK,EAAKM,WACb,IAAIH,UAAWN,EAAQ,8DAA+D,WAAYG,EAAKM,WAG3GpB,EAAYe,EAAS,mBACzBD,EAAKO,cAAgBN,EAAQM,eACvBjB,EAAWU,EAAKO,gBACd,IAAIJ,UAAWN,EAAQ,+DAAgE,gBAAiBG,EAAKO,gBAGjHrB,EAAYe,EAAS,mBACzBD,EAAKQ,cAAgBP,EAAQO,eACvBf,EAAeO,EAAKQ,gBAClB,IAAIL,UAAWN,EAAQ,0EAA2E,gBAAiBG,EAAKQ,gBAG5HtB,EAAYe,EAAS,mBACzBD,EAAKS,cAAgBR,EAAQQ,eACvBnB,EAAWU,EAAKS,gBACd,IAAIN,UAAWN,EAAQ,+DAAgE,gBAAiBG,EAAKS,gBAG/G,KA5CC,IAAIN,UAAWN,EAAQ,qEAAsEI,KC3BlGS,EAAWvB,EAKXwB,EANS1B,EAMO,4BA4CpB,IAAA2B,EAhCA,SAAkBC,GAEjB,IAAIC,EACJ,OAAKC,KAAKC,YACTL,EAAO,qDACAI,OAERD,EAAOC,KACPA,KAAKC,YAAa,EAElBN,GASA,WACMG,IACJF,EAAO,mDAAoDM,KAAKC,UAAWL,IAC3EC,EAAKK,KAAM,QAASN,IAErBF,EAAO,yBACPG,EAAKK,KAAM,YAbLJ,OCzBJJ,EALS1B,EAKO,8BAqBpB,IAAAmC,EARA,SAAoBC,EAAOf,EAAUgB,GACpCX,EAAO,iDAAkDU,EAAME,WAAYjB,GAC3EgB,EAAM,KAAMD,ICpBTG,GAASvC,EACTH,GAAYK,EAA6BL,UACzC2C,GAAUpC,EACVqC,GAAOnC,EACPoC,GAAWjC,EACXkC,GAAWhC,EACXiC,GAAU/B,EACVsB,GAAaU,EAKbnB,GAAQa,GAAQ,yBA0CpB,SAASO,GAAiB9B,GACzB,IAAID,EACAgC,EACJ,KAAQjB,gBAAgBgB,IACvB,OAAKE,UAAUC,OACP,IAAIH,GAAiB9B,GAEtB,IAAI8B,GAGZ,GADA/B,EAAO0B,GAAMC,IACRM,UAAUC,SACdF,EAAMJ,GAAU5B,EAAMC,IAErB,MAAM+B,EAcR,OAXArB,GAAO,yEAA0EM,KAAKC,UAAWlB,IACjGlB,GAAUqD,KAAMpB,KAAMf,GACtBe,KAAKC,YAAa,EACbhB,EAAKE,UACTa,KAAKK,WAAapB,EAAKE,UAEvBa,KAAKK,WAAaA,GAEdpB,EAAKI,QACTW,KAAKqB,OAASpC,EAAKI,OAEbW,KAMRU,GAASM,GAAiBjD,IAW1BiD,GAAgBM,UAAUR,QAAUA,GAKpC,IAAAS,GAAiBP,GCvGb/C,GAAWC,EACXY,GAASV,EACTuC,GAAOrC,EACPb,GAASe,GAiEb,IAAAgD,GAjBA,SAAqBtC,GACpB,IAAID,EACJ,GAAKiC,UAAUC,OAAS,CACvB,IAAMlD,GAAUiB,GACf,MAAM,IAAIE,UAAWN,GAAQ,qEAAsEI,IAEpGD,EAAO0B,GAAMzB,QAEbD,EAAO,GAGR,OADAA,EAAKK,YAAa,EACX,IAAI7B,GAAQwB,IC9DhBhB,GAAWC,EACXY,GAASV,EACTuC,GAAOrC,EACPb,GAASe,GA2Eb,IAAAiD,GArCA,SAAwBvC,GACvB,IAAID,EACJ,GAAKiC,UAAUC,OAAS,CACvB,IAAMlD,GAAUiB,GACf,MAAM,IAAIE,UAAWN,GAAQ,qEAAsEI,IAEpGD,EAAO0B,GAAMzB,QAEbD,EAAO,GAER,OAAOyC,EAaP,SAASA,EAAcvC,EAAWE,GAOjC,OANAJ,EAAKE,UAAYA,EACZ+B,UAAUC,OAAS,EACvBlC,EAAKI,MAAQA,SAENJ,EAAKI,MAEN,IAAI5B,GAAQwB,KCvEjBwB,GAASvC,EACTH,GAAYK,EAA6BL,UACzC2C,GAAUpC,EACVqC,GAAOnC,EACPoC,GAAWjC,EACXkC,GAAWhC,EACXiC,GAAU/B,EACVsB,GAAaU,EAKbnB,GAAQa,GAAQ,yBAmKpB,IAAAkB,GAtHA,SAAezC,GACd,IAAIC,EACAyC,EACAX,EAGJ,GADAW,EAAQjB,GAAMC,IACTM,UAAUC,SACdF,EAAMJ,GAAUe,EAAO1C,IAEtB,MAAM+B,EAsCR,SAASD,EAAiB9B,GACzB,IAAID,EACAgC,EACJ,KAAQjB,gBAAgBgB,GACvB,OAAKE,UAAUC,OACP,IAAIH,EAAiB9B,GAEtB,IAAI8B,EAGZ,GADA/B,EAAO0B,GAAMiB,GACRV,UAAUC,SACdF,EAAMJ,GAAU5B,EAAMC,IAErB,MAAM+B,EAMR,OAHArB,GAAO,yEAA0EM,KAAKC,UAAWlB,IACjGlB,GAAUqD,KAAMpB,KAAMf,GACtBe,KAAKC,YAAa,EACXD,KA8CR,OAnGCb,EADIyC,EAAMzC,UACEyC,EAAMzC,UAENkB,GAyDbK,GAASM,EAAiBjD,IAa1BiD,EAAgBM,UAAUjB,WAAalB,EAElCyC,EAAMvC,QAUV2B,EAAgBM,UAAUD,OAASO,EAAMvC,OAa1C2B,EAAgBM,UAAUR,QAAUA,GAE7BE,GC7DRa,GAAA3D,EACAiB,GAAAf,GACAkB,GAAAhB,GACAmD,GAAAjD,GACAsD,GAAAnD,GAKAkD,GAAA1C,GAAA,aAAAG,IACAuC,GAAA1C,GAAA,UAAAsC,IACAI,GAAA1C,GAAA,OAAA2C,IAKA,IAAAC,GAAA5C"}